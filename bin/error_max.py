'''
This file is automatically called by NOMAD to select new sample points.
The program evaluates both the true model (e.g. a HYSYS simulation) and
the surrogate model (via the Surrogate object). It then calculates the
maximum error between the true model and surrogate model (which is used
for error-maximization sampling), as well as constraints on the input
space (which is used by NOMAD to prevent sampling uninteresting regions).
All input/output is performed using the conventions expected by NOMAD.
'''

# Import system libraries
import numpy as np
import pickle
import sys
import os

# Add project libraries to path
sys.path.append(os.path.normpath(os.path.join(__file__, '..', '..', 'lib')))


############################################################
# PART I: Initialization procedure.
############################################################
# This includes loading data from input files autogenerated
# by main.py/nomad.py and preparing for the calculations.
############################################################

# Import the user-defined simulator
sys.path.append(os.getcwd())
from true_model import simulate

# Load the generated surrogate models
with open('surrogate.pkl', 'rb') as f:
	surrogates, indices = pickle.load(f)[0]
	surrogate = surrogates[0]

# Check what point NOMAD has requested
# (Standardized so that 0 ≤ x[i] ≤ 1.)
x = np.loadtxt(sys.argv[1])

# Ensure the result is an array
if x.shape == ():
	x = np.array([x])

# Unstandardize the sample coordinates
x_un = np.array(surrogate.restore(x))

# Load all previously sampled data
coords  = np.genfromtxt('samples.csv', delimiter=',')[:, 1:len(x) + 1 ]
results = np.genfromtxt('samples.csv', delimiter=',')[:,   len(x) + 1:]



############################################################
# PART II: Constraints validation.
############################################################
# This part of the program loads input parameter constraints
# from file (if they have been defined), and uses them to
# ensure the requested sample point is within constraints.
# Note that only inequality constraints have to be checked
# here, since box constraints are automatically satisifed.
############################################################

if surrogate.data: 
	# Load inequality constraints from file
	with open('InEq_constraints.pkl', 'rb') as f:
		ineq_A, ineq_b, ind_flow = pickle.load(f)
	
	# Evaluate the constraints:
	constraints = np.matmul(ineq_A,x_un[ind_flow]) - ineq_b
else:
	# No inequality constraints defined
	constraints = []

# Check for constraint violations. If the constraints are violated,
# there is no reason to waste computational time on this data point.
if not all([i < 0 for i in constraints]):
	print(0, *constraints)
	sys.exit(0)



############################################################
# PART III: Simulation and memoization.
############################################################
# First, check whether this point has been sampled before,
# in which case we can simply return a known value. If not,
# we have to invoke the simulator to sample new data. Either
# way, we also need to calculate an objective function here,
# and communicate the results to NOMAD and output files.
############################################################

# Search for this sample point in the cache from previous
# calculations. If we find a match, skip new calculations.
# If not, remember to save the new results to the cache.
search = [i for i, xi in enumerate(coords) if all(x==xi)]
if search:
	# Use previous evaluations
	z = results[search[0]]
else:
	# Perform new simulation
	z = simulate(x_un)
	
	# Save the result to file
	with open('nomad.csv', 'a+') as f:
		np.savetxt(f, [[*x, *z]], delimiter=',')

# Find the magnitude of variation of each output component. This is
# used to scale the errors in each component of the surrogate model.
deviation = np.max(results[:, indices], axis=0) \
          - np.min(results[:, indices], axis=0)

# If there is zero deviation, we cannot use this as a relative scale;
# in that case, we should simply revert to using an absolute scale.
for i, v in enumerate(deviation):
	if v == 0:
		deviation[i] = 1

# This measures the square error between our surrogate model and
# the true model. The minus sign is needed because the optimizer
# tries to *minimize* the objective, while we want to *maximize* 
# the error when we are looking for a new sample point.
objective = - sum( ((z[i]-surrogates[i](x))/deviation[k])**2 
                   for k, i in enumerate(indices) )

# Calculate a penalty based on previously sampled coordinates
A = surrogate.conf['adapt_pen']
R = surrogate.conf['adapt_rad']
penalty = A * sum(np.exp(-sum(((x - xi) / R) ** 2)) for xi in coords)
 
# Print out NOMAD objective and constraints. Note that NOMAD expects
# this blackbox program to return the evaluation values by displaying
# them to stdout. It must also return an evaluation status of 0 to
# indicate successful evaluation, which Python does by default.
print(objective + penalty, *constraints)

# Record the maximal error to a file
error = np.sqrt(np.abs(objective))
with open('nomad.err', 'a+') as f:
	np.savetxt(f, [error], delimiter=',')
